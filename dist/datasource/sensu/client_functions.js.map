{"version":3,"file":"client_functions.js","sourceRoot":"src/","sources":["datasource/sensu/client_functions.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n\n */\n import { getResponseForTarget, getClientsWithFilter } from \"./common\";\n\n function getClientsURIs(checkNames, clientNames) {\n   var uris = [];\n   var dimensionURI = \"/clients\";\n   // look for clientName in dimensions\n   if (clientNames.length) {\n     for (let i = 0; i < clientNames.length; i++) {\n       var aClientName = clientNames[i];\n       dimensionURI = \"/clients/\" + aClientName;\n       uris.push(dimensionURI);\n     }\n   }\n   if (uris.length === 0) {\n     uris.push(dimensionURI);\n   }\n   uris.push(\"/events\");\n   uris.push(\"/results\");\n\n   return uris;\n }\n\n\n/**\n * [convertClientsToDataPoints description]\n * @param  {[type]} response [description]\n * @return {[type]}          [description]\n */\nfunction convertClientsToDataPoints(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n  // the result has no \"datapoints\", need to create it based on the check data\n  // when we have a checkname and an clientName, the response is different, the\n  // data is not an array, but contains the same information, recreate and push\n  if (response.data.length === undefined) {\n    var singleData = response.data;\n    response.data = [];\n    response.data.push(singleData);\n  }\n  switch (aTarget.clientQueryMode) {\n    case \"list\":\n      let filterData = [];\n      let arrClientNames = [];\n      if ((aTarget.filters !== undefined) && (aTarget.filters.length > 0)) {\n        arrClientNames = getClientsWithFilter(aTarget, response);\n        // iterate over the data and store the matching clients in the new filteredData\n        for (let i = 0; i < response.data.length; i++) {\n          // push matching client names\n          if (arrClientNames.indexOf(response.data[i].name) >= 0) {\n            filterData.push(response.data[i]);\n          }\n        }\n        // now replace data with filtered data\n        response.data = filterData;\n      }\n      for (let i = 0; i < response.data.length; i++) {\n        let data = response.data[i];\n        let datapoints = [];\n        if (data.timestamp !== undefined) {\n          datapoints[0] = [1, (data.timestamp * 1000)];\n        }\n        data.datapoints = datapoints;\n        // set the target\n        data.target = data.name;\n      }\n      break;\n    case \"count\":\n      if (response.data.length > 0) {\n        let data = response.data[0];\n        let datapoints = [];\n        let clientCount = 0;\n        let arrClientNames = [];\n        if ((aTarget.filters !== undefined) && (aTarget.filters.length > 0)) {\n          arrClientNames = getClientsWithFilter(aTarget, response);\n          clientCount = arrClientNames.length;\n        } else {\n          clientCount = response.data.length;\n        }\n        if (data.timestamp !== undefined) {\n          datapoints[0] = [clientCount, (data.timestamp * 1000)];\n        }\n        data.datapoints = datapoints;\n        // set the target\n        data.address = undefined;\n        data.name = undefined;\n        data.socket = undefined;\n        data.subscriptions = undefined;\n        data.version = undefined;\n        data.target = \"ClientCount\";\n        if (aTarget.aliasReplaced) {\n          data.target = aTarget.aliasReplaced;\n        }\n        response.data = [data];\n      }\n      break;\n  }\n  return response;\n}\n\n/**\n * [convertClientsToJSON description]\n * @param  {[type]} response [description]\n * @param  {[type]} aTarget  [description]\n * @return {[type]}          [description]\n */\nfunction convertClientsToJSON(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n  if (response.data.length === undefined) {\n    var data = response.data;\n    response.data = [];\n    response.data.push(data);\n  }\n  // start with an empty list\n  var newData = [];\n  for (var i = 0; i < response.data.length; i++) {\n    // default to adding the items, filters will set this to false as needed\n    let pushItem = true;\n    // clone it\n    let item = JSON.parse(JSON.stringify(response.data[i]));\n    // empty datapoints\n    item.datapoints = [];\n    // set the type to docs\n    item.type = \"docs\";\n    //item.value = 0;\n    // if there\"s no address, it is a JIT client\n    var address = item.address;\n    if (item.address === \"unknown\") {\n      item.address = \"JIT Client\";\n    }\n    // check filters\n    if (aTarget.filters !== undefined) {\n      if (aTarget.filters.length !== undefined) {\n        for (var j = 0; j < aTarget.filters.length; j++) {\n          var aFilter = aTarget.filters[j];\n          switch (aFilter.filterType) {\n            case \"regex\":\n              // make sure the regex is valid\n              try {\n                var flags = aFilter.filterRegexFlags;\n                var re = new RegExp(aFilter.filterRegex, flags);\n                if (re.test(item.name)) {\n                  // push this one\n                  //console.log(\"matched regex\");\n                  aFilter.filterMessage = \"OK\";\n                } else {\n                  pushItem = false;\n                }\n              } catch (err) {\n                aFilter.filterMessage = \"Invalid Regular Expression\";\n                //console.log(\"Invalid Regex Detected!\");\n                break;\n              }\n              break;\n            case \"field\":\n              if (item.hasOwnProperty(aFilter.filterFieldName)) {\n                let fieldVal = item[aFilter.filterFieldName];\n                if (fieldVal !== aFilter.filterFieldValueReplaced) {\n                  pushItem = false;\n                }\n              } else {\n                // no field, no push\n                pushItem = false;\n              }\n              break;\n          }\n        }\n      }\n    }\n    // push into the datapoints\n    if (pushItem) {\n      //itemData.datapoints.push(itemData);\n      var entry = {\n        type: \"docs\",\n        datapoints: [item]\n      };\n      newData.push(entry);\n    }\n  }\n  response.data = newData;\n  return response;\n}\n\n/**\n * [convertClientHistoryToDataPoints description]\n * @param  {[type]} response [description]\n * @return {[type]}        [description]\n */\nfunction convertClientHistoryToDataPoints(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n  // the result has no \"datapoints\", need to create it based on the check data\n  // when we have a checkname and an clientName, the response is different, the\n  // data is not an array, but contains the same information, recreate and push\n  //if (response.data.length === undefined) {\n  //  var singleData = response.data;\n  //  response.data = [];\n  //  response.data.push(singleData);\n  //}\n  for (var i = 0; i < response.data.length; i++) {\n    var anEvent = response.data[i];\n    var datapoints = [];\n    var startingTimestamp = 0;\n    if (anEvent.last_execution !== undefined) {\n      startingTimestamp = anEvent.last_execution - (60 * anEvent.history.length);\n    }\n    // time needs to be in MS, we get EPOCH from Sensu\n    if (anEvent.history !== undefined) {\n      for (var y = 0; y < anEvent.history.length; y++) {\n        datapoints[y] = [anEvent.history[y], (startingTimestamp + (60 * y)) * 1000];\n      }\n    }\n    anEvent.datapoints = datapoints;\n    // set the target to be the check name\n    anEvent.target = \"unknown\";\n    if (anEvent.name !== undefined) {\n      anEvent.target = anEvent.name;\n    }\n    if (anEvent.check !== undefined) {\n      anEvent.target = anEvent.check;\n    }\n  }\n  return response;\n}\n\n/**\n * Returns JSON with the following:\n *    #Checks\n *    #Checks silenced\n *    #Checks OK\n *    #Checks warning\n *    #Checks Critical\n *    #Clients\n *    #Clients silenced\n *    #Clients OK\n *    #Clients warning\n *    #Clients Critical\n * @param  {[type]} responses [description]\n * @return {[type]}           [description]\n */\nfunction convertClientSummaryMetricsToJSON(aTarget, responses) {\n  var response = getResponseForTarget(aTarget, responses);\n\n}\n\n\nexport {\n  convertClientsToDataPoints,\n  convertClientsToJSON,\n  convertClientHistoryToDataPoints,\n  convertClientSummaryMetricsToJSON,\n  getClientsURIs\n};\n"]}